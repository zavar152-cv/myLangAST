// START:header
grammar Example;

options {
    language=C;
    output=AST;
    ASTLabelType = pANTLR3_BASE_TREE;
} // build trees

tokens {
    EXPR;
    TERM;
    BINARY_OP;
    UNARY_OP;
    BRACES;
    PLACE;
    LITERAL;
    PLUS;
    MINUS;
    MUL;
    NEG;
    NOT;
    BOOL;
    STR;
    RUNE;
    HEX;
    BITS;
    DEC;
    IDENTIFIER;
    BUILTIN_TYPE;
    CUSTOM_TYPE;
    ARRAY_TYPE;
    SOURCE_ITEM;
    VAR;
}

source
    : var
    | expr
    ;

var
    : typeRef identifier -> ^(VAR typeRef identifier)
    ;


typeRef
    : baseType (arraySuffix)*  // Base types followed by optional array suffixes
    ;

baseType
    : builtinType
    | customType
    ;

builtinType
    : 'bool'
    | 'byte'
    | 'int'
    | 'uint'
    | 'long'
    | 'ulong'
    | 'char'
    | 'string'
    ;

customType
    : identifier
    -> ^(CUSTOM_TYPE identifier)
    ;

// Array suffix rule to handle array types
arraySuffix
    : '[' (typeRef (',' typeRef)*)? ']' -> ^(ARRAY_TYPE typeRef (typeRef)*)
    ;

expr
    : l=term (binOp^ r=term)*
    ;

term
    : unary
    | braces
    | place
    | literal
    ;

unary
    : unOp^ expr
    ;

braces
    : '(' expr ')'
    ;

place
    : identifier -> ^(IDENTIFIER identifier)
    ;

literal
    : bool -> ^(BOOL bool)
    | str -> ^(STR str)
    | rune -> ^(RUNE rune)
    | hex -> ^(HEX hex)
    | bits -> ^(BITS bits)
    | dec -> ^(DEC dec)
    ;

binOp
    : plus -> PLUS
    | minus -> MINUS
    | mul -> MUL
    ;
//| '/' | '==' | '!=' | '<' | '>' | '<=' | '>=' 
unOp
    : minus -> NEG
    | exclMark -> NOT
    ;

// Terminal
identifier: IDENTIFIER_TOKEN;

str: STR_TOKEN;
rune: CHAR_TOKEN;
hex: HEX_TOKEN;
bits: BITS_TOKEN;
dec: DEC_TOKEN;
bool: BOOL_TOKEN;
minus: MINUS_TOKEN;
exclMark: EXCL_MARK_TOKEN;
plus: PLUS_TOKEN;
mul: MUL_TOKEN;

MINUS_TOKEN: '-';
EXCL_MARK_TOKEN: '!';
PLUS_TOKEN: '+';
MUL_TOKEN: '*';

BOOL_TOKEN: (TRUE | FALSE) ;
IDENTIFIER_TOKEN: (ALPHA | SPECIAL) (ALPHA | SPECIAL | DIGIT)* ;
BITS_TOKEN: '0' ('b'|'B') BINARY_DIGIT+ ;
HEX_TOKEN: '0'('x'|'X') HEX_DIGIT+ ;
DEC_TOKEN: DIGIT+ ;
CHAR_TOKEN: '\'' ~('\'') '\'' ;
STR_TOKEN: ('"') ('\\' . | ~('\\'|'"'))* ('"') ;

NEWLINE:'\r'? '\n' { SKIP(); };
WSS: WS+ { SKIP(); };


fragment TRUE: 'true';
fragment FALSE: 'false';
fragment ALPHA: ('a'..'z' | 'A'..'Z');
fragment SPECIAL: ('_');
fragment DIGIT: ('0'..'9');
fragment BINARY_DIGIT: ('0' | '1');
fragment HEX_DIGIT: ('0'..'9' | 'a'..'f' | 'A'..'F');
fragment WS:(' '|'\t') ;