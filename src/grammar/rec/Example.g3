// START:header
grammar Example;

options {
    language=C;
    output=AST;
    ASTLabelType = pANTLR3_BASE_TREE;
} // build trees

tokens {
    EXPR;
    TERM;
    BINARY_OP;
    UNARY_OP;
    BRACES;
    PLACE;
    LITERAL;
    PLUS;
    MINUS;
    MUL;
    ASSIGN;
    NEG;
    NOT;
    BOOL;
    STR;
    RUNE;
    HEX;
    BITS;
    DEC;
    IDENTIFIER;
    BUILTIN_TYPE;
    CUSTOM_TYPE;
    ARRAY;
    SOURCE_ITEM;
    VAR;
    SOURCE;
    TYPE;
    LIST;
    INIT;
    ARRAY_SIZE;
}

source
    :
    sourceItem+ -> ^(SOURCE sourceItem+)
    ;

sourceItem
    : var ';' -> var
    | expr ';' -> expr
    | array ';' -> array
    ;

var
    : typeRef ((identifier ('=' expr)?) (',' (identifier ('=' expr)?))*) -> ^(VAR ^(TYPE typeRef) ^(IDENTIFIER identifier)* ^(INIT identifier expr)*)
    ;

//WTF is size?
array
    : typeRef '[' size+=(',')* ']' ((identifier ('=' expr)?) (',' (identifier ('=' expr)?))*) -> ^(ARRAY ^(TYPE typeRef) ^(IDENTIFIER identifier)* ^(INIT identifier expr)* ^(ARRAY_SIZE $size*)?)
    ;

typeRef
    : baseType
    ;

baseType
    : builtinType
    | customType
    ;
//add rewrite-rule as customType
builtinType
    : boolType
    | byteType
    | intType
    | uintType
    | longType
    | ulongType
    | charType
    | stringType
    ;

customType
    : identifier
    -> ^(CUSTOM_TYPE identifier)
    ;

expr
    : assignmentExpr
    ;

assignmentExpr
    : addExpr (assign^ addExpr)?
    ;

addExpr
    : mulExpr ((plus^ | minus^) mulExpr)*
    ;

mulExpr
    : unaryExpr ((mul^ | divide^) unaryExpr)*
    ;

unaryExpr
    : unOp^ unaryExpr
    | primary
    ;

primary
    : braces
    | place
    | literal
    ;

braces
    : '(' expr ')' -> expr
    ;

place
    : identifier -> ^(IDENTIFIER identifier)
    ;

literal
    : boolLit -> ^(BOOL boolLit)
    | str -> ^(STR str)
    | rune -> ^(RUNE rune)
    | hex -> ^(HEX hex)
    | bits -> ^(BITS bits)
    | dec -> ^(DEC dec)
    ;

binOp
    : assign
    | plus
    | minus
    | mul
    | divide
    | eq
    | neq
    | le
    | gr
    | leEq
    | grEq
    ;

unOp
    : minus -> NEG
    | exclMark -> NOT
    ;

identifier: IDENTIFIER_TOKEN;

str: STR_TOKEN;
rune: CHAR_TOKEN;
hex: HEX_TOKEN;
bits: BITS_TOKEN;
dec: DEC_TOKEN;
boolLit: BOOL_TOKEN;
minus: MINUS_TOKEN;
exclMark: EXCL_MARK_TOKEN;
plus: PLUS_TOKEN;
mul: MUL_TOKEN;
assign: ASSIGN_TOKEN;
divide: DIV_TOKEN;
eq: EQ_TOKEN;
neq: NEQ_TOKEN;
le: LE_TOKEN;
gr: GR_TOKEN;
leEq: LE_EQ_TOKEN;
grEq: GR_EQ_TOKEN;

boolType: BOOL_TYPE;
byteType: BYTE_TYPE;
intType: INT_TYPE;
uintType: UINT_TYPE;
longType: LONG_TYPE;
ulongType: ULONG_TYPE;
charType: CHAR_TYPE;
stringType: STRING_TYPE;

MINUS_TOKEN: '-';
EXCL_MARK_TOKEN: '!';
PLUS_TOKEN: '+';
MUL_TOKEN: '*';
ASSIGN_TOKEN: '=';
DIV_TOKEN: '/';
EQ_TOKEN: '==';
NEQ_TOKEN: '!=';
LE_TOKEN: '<';
GR_TOKEN: '>';
LE_EQ_TOKEN: '<=';
GR_EQ_TOKEN: '>=';

BOOL_TYPE: 'bool';
BYTE_TYPE: 'byte';
INT_TYPE: 'int';
UINT_TYPE: 'uint';
LONG_TYPE: 'long';
ULONG_TYPE: 'ulong';
CHAR_TYPE: 'char';
STRING_TYPE: 'string';

BOOL_TOKEN: (TRUE | FALSE) ;
IDENTIFIER_TOKEN: (ALPHA | SPECIAL) (ALPHA | SPECIAL | DIGIT)* ;
BITS_TOKEN: '0' ('b'|'B') BINARY_DIGIT+ ;
HEX_TOKEN: '0'('x'|'X') HEX_DIGIT+ ;
DEC_TOKEN: DIGIT+ ;
CHAR_TOKEN: '\'' ~('\'') '\'' ;
STR_TOKEN: ('"') ('\\' . | ~('\\'|'"'))* ('"');

NEWLINE:'\r'? '\n' { SKIP(); };
WSS: WS+ { SKIP(); };


fragment TRUE: 'true';
fragment FALSE: 'false';
fragment ALPHA: ('a'..'z' | 'A'..'Z');
fragment SPECIAL: ('_');
fragment DIGIT: ('0'..'9');
fragment BINARY_DIGIT: ('0' | '1');
fragment HEX_DIGIT: ('0'..'9' | 'a'..'f' | 'A'..'F');
fragment WS:(' '|'\t') ;